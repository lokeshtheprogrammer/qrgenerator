<div id="qrcode"></div>
<script>
	// Error correction levels
var QRErrorCorrectLevel = { L: 1, M: 0, Q: 3, H: 2 };

// Math for QR (Galois Field 256)
var QRMath = {
  EXP_TABLE: new Array(256),
  LOG_TABLE: new Array(256),
  glog: function(n) {
    if (n < 1) throw new Error("glog(" + n + ")");
    return QRMath.LOG_TABLE[n];
  },
  gexp: function(n) {
    while (n < 0) n += 255;
    while (n >= 256) n -= 255;
    return QRMath.EXP_TABLE[n];
  }
};

// Initialize math tables
for (let i = 0; i < 8; i++) QRMath.EXP_TABLE[i] = 1 << i;
for (let i = 8; i < 256; i++)
  QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^
                        QRMath.EXP_TABLE[i - 5] ^
                        QRMath.EXP_TABLE[i - 6] ^
                        QRMath.EXP_TABLE[i - 8];
for (let i = 0; i < 255; i++)
  QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;

// Polynomial class
function QRPolynomial(num, shift) {
  let offset = 0;
  while (offset < num.length && num[offset] == 0) offset++;
  this.num = new Array(num.length - offset + shift);
  for (let i = 0; i < num.length - offset; i++)
    this.num[i] = num[i + offset];
}
QRPolynomial.prototype = {
  get: function(index) { return this.num[index]; },
  getLength: function() { return this.num.length; },
  multiply: function(e) {
    let num = new Array(this.getLength() + e.getLength() - 1);
    for (let i = 0; i < this.getLength(); i++) {
      for (let j = 0; j < e.getLength(); j++) {
        num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
      }
    }
    return new QRPolynomial(num, 0);
  },
  mod: function(e) {
    if (this.getLength() - e.getLength() < 0) return this;
    let ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
    let num = this.num.slice();
    for (let i = 0; i < e.getLength(); i++) {
      num[i] ^= QRMath.gexp(QRMath.glog(e.get(i)) + ratio);
    }
    return new QRPolynomial(num, 0).mod(e);
  }
};
function QRBitBuffer() {
  this.buffer = [];
  this.length = 0;
}
QRBitBuffer.prototype = {
  get: function(index) {
    const bufIndex = Math.floor(index / 8);
    return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1;
  },
  put: function(num, length) {
    for (let i = 0; i < length; i++) {
      this.putBit(((num >>> (length - i - 1)) & 1) === 1);
    }
  },
  putBit: function(bit) {
    const bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) this.buffer.push(0);
    if (bit) this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
    this.length++;
  },
  getLengthInBits: function() {
    return this.length;
  }
};
QRCodeModel.prototype.getLostPoint = function(qrCode) {
  let moduleCount = qrCode.getModuleCount();
  let lostPoint = 0;

  // Rule 1: Same color blocks
  for (let row = 0; row < moduleCount; row++) {
    for (let col = 0; col < moduleCount; col++) {
      let sameCount = 0;
      let dark = qrCode.isDark(row, col);
      for (let r = -1; r <= 1; r++) {
        for (let c = -1; c <= 1; c++) {
          if (row + r < 0 || moduleCount <= row + r || col + c < 0 || moduleCount <= col + c) {
            continue;
          }
          if (dark === qrCode.isDark(row + r, col + c)) {
            sameCount++;
          }
        }
      }
      if (sameCount > 5) {
        lostPoint += (3 + sameCount - 5);
      }
    }
  }

  // Rule 2: 2x2 blocks of same color
  for (let row = 0; row < moduleCount - 1; row++) {
    for (let col = 0; col < moduleCount - 1; col++) {
      let count = 0;
      if (qrCode.isDark(row, col)) count++;
      if (qrCode.isDark(row + 1, col)) count++;
      if (qrCode.isDark(row, col + 1)) count++;
      if (qrCode.isDark(row + 1, col + 1)) count++;
      if (count === 0 || count === 4) {
        lostPoint += 3;
      }
    }
  }

  // Rule 3: Patterns that look like finder patterns
  for (let row = 0; row < moduleCount; row++) {
    for (let col = 0; col < moduleCount - 6; col++) {
      if (
        qrCode.isDark(row, col) &&
        !qrCode.isDark(row, col + 1) &&
        qrCode.isDark(row, col + 2) &&
        qrCode.isDark(row, col + 3) &&
        qrCode.isDark(row, col + 4) &&
        !qrCode.isDark(row, col + 5) &&
        qrCode.isDark(row, col + 6)
      ) {
        lostPoint += 40;
      }
    }
  }
  for (let col = 0; col < moduleCount; col++) {
    for (let row = 0; row < moduleCount - 6; row++) {
      if (
        qrCode.isDark(row, col) &&
        !qrCode.isDark(row + 1, col) &&
        qrCode.isDark(row + 2, col) &&
        qrCode.isDark(row + 3, col) &&
        qrCode.isDark(row + 4, col) &&
        !qrCode.isDark(row + 5, col) &&
        qrCode.isDark(row + 6, col)
      ) {
        lostPoint += 40;
      }
    }
  }

  // Rule 4: Proportion of dark modules
  let darkCount = 0;
  for (let row = 0; row < moduleCount; row++) {
    for (let col = 0; col < moduleCount; col++) {
      if (qrCode.isDark(row, col)) {
        darkCount++;
      }
    }
  }
  const ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
  lostPoint += ratio * 10;
  return lostPoint;
};
const svgDrawer = (function() {
  const Drawing = function(el, options) {
    this._el = el;
    this._options = options;
  };
  Drawing.prototype.draw = function(qrCode) {
    const nCount = qrCode.getModuleCount();
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", `0 0 ${nCount} ${nCount}`);
    svg.setAttribute("width", "100%");
    svg.setAttribute("height", "100%");
    svg.setAttribute("fill", this._options.colorLight);

    svg.appendChild(
      document.createElementNS("http://www.w3.org/2000/svg", "rect")
    );

    for (let row = 0; row < nCount; row++) {
      for (let col = 0; col < nCount; col++) {
        if (qrCode.isDark(row, col)) {
          const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          rect.setAttribute("x", col);
          rect.setAttribute("y", row);
          rect.setAttribute("width", 1);
          rect.setAttribute("height", 1);
          rect.setAttribute("fill", this._options.colorDark);
          svg.appendChild(rect);
        }
      }
    }
    this._el.innerHTML = "";
    this._el.appendChild(svg);
  };
  return Drawing;
})();
// Example
const qrcode = new QRCode(document.getElementById("qrcode"), {
  text: "https://example.com",
  width: 256,
  height: 256,
  colorDark: "#000000",
  colorLight: "#ffffff",
  correctLevel: QRErrorCorrectLevel.H
});
 const qrcode = new QRCode(document.getElementById("qrcode"), {
    text: "https://example.com",
    width: 256,
    height: 256
  });
</script>
